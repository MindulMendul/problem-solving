// (정답 28, 물론 얘는 조건 범위가 좀 벗어나긴 함;;) 8 2200000000 2200000000 2200000000 2200000000 2200000000 2200000000 2200000000 2200000000
// (정답 12) 8 2 4 1 2 2 1 5 1
// (정답 13) 8 8 6 4 2 1 3 5 7

// 문제 풀이
// 스택 + 이분탐색 을 이용해서 풀어야 함.
// count 증가하는 것과 스택의 pop 연산을 따로 생각해서 구하기.
// 스택에 있는 값이 들어오는 값보다 커지는 순간까지 count가 증가.
// 스택의 맨 위에 있는 값이 들어오는 값보다 클 때까지 pop 연산 진행.
// 이 위치를 각각 이분 탐색을 진행해서 위치를 찾아야 함.

#include <iostream>

using namespace std;

long long int stack[500'000]; // 스택을 이용해서 정답을 구할 예정

int main(){
	freopen("input.txt", "rt", stdin);
  ios::sync_with_stdio(false);
  cin.tie(NULL);
  cout.tie(NULL);

	// 일반 배열에다가 top 변수로 스택의 top index를 찍어줄 예정.
	// 어차피 N<500'000이라서 int로 해도 됨.
	int N, top=0; cin>>N; 
	long long int ans=0; // 정답
	for(int i=0; i<N; i++){
		// 현재 들어오는 값을 in이라고 지정
		long long int in; cin>>in;

/////////////////////////////////////////////////////////////////////////////////////

		// 1. 스택에 있는 값이 in보다 커지는 순간을 찾아야 함.
		int s=0, e=top-1, mid;
		while(s<e){
			mid=(s+e)/2;
			// mid에 있는 값이 in보다 작거나 같으면 왼쪽 탐색,
			// 아니면 오른쪽 탐색
			if(stack[mid]<=in) e=mid-1;
			else s=mid+1;
		}

		// 이분탐색이 끝났으면 그 주변에서 위치를 정확히 찾아야 함
		// s가 0 보다 큰데 (즉, 스택에 뭐가 들어있는데) s index값이 in보다 작다면 s-1가 정확한 위치
		// 그게 아니라면 s가 정확한 위치
		if(s>0 && stack[s]<=in) ans+=top-s+1; else ans+=top-s;

/////////////////////////////////////////////////////////////////////////////////////

		// 2.. 스택의 맨 위에 있는 값이 in보다 클 때까지 pop 연산 진행.
		s=0; e=top-1;
		while(s<e){
			mid=(s+e)/2;
			// mid에 있는 값이 in보다 작으면 왼쪽 탐색,
			// 아니면 오른쪽 탐색
			if(stack[mid]<in){e=mid-1;}
			else {s=mid+1;}
		}

		// 이분탐색이 끝났으면 그 주변에서 위치를 정확히 찾아야 함
		// s index값이 in보다 작다면 s까지 빼주면 됨.
		// 그게 아니라면 s의 다음에 in을 받아야 함.
		if(stack[s]<in) top=s; else top=s+1;

/////////////////////////////////////////////////////////////////////////////////////
		
		// in을 진짜 스택에 담아줘야 함.
		stack[top++]=in;
	}
	cout<<ans;

  return 0;
}
